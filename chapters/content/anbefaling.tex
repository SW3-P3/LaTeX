\section{Anbefalingssystem}\label{anbefaling}
At udvikle og implementere et anbefalingssystem vil opfylde user story 14.
For at lave dette kræves implementering af stories 13 og 15.
Først vil der gennemgås teori om anbefalingssystemer, efterfølgende beskrives vores design og implementering.
Til sidst konkluderes på denne del af vores system.
Anbefalingssystemet har ikke været en kerneområde dette projekt, og derfor foreslår vi også en del forbedringer i konklusionen, som vi ikke har prioriteret at implementere i projektets forløb.

\subsection{Teori}
Inden for anbefalingssystemer findes der mange forskellige retninger.
Hvilken retning et givent projekt benytter sig af ender ud i nogle valg om hvilke typer anbefalinger man ønsker, samt hvilke data man er i besiddelse af, hvorpå man kan basere sine anbefalinger.
I følgende afsnit gennemgås kort nogle forskellige grene og designs inden for anbefalingssystemer.

Nogle af de simpleste anbefalingssystemer, er upersonlige anbefalinger.
Eksempler på dette kan være en simpel sortering af objekter.
Sådanne sorteringer vil ofte være baseret på ting som popularitet, salg, sidevisninger eller lignende.
Den anden overordnede retning inden for anbefaling er personlig anbefaling, dette vil sige at systemet benytter noget data om en bruger, til at anbefale ting, der kunne være særlig interessant for brugeren.
Ved sådanne personlige anbefalinger skal systemet bruge en smagsprofil af dets brugere, for at personliggøre anbefalingerne.
Der findes flere forskellige metoder til at generere personlige anbefalinger, vi vil herunder kort fortælle om to af de mest brugte hovedretninger\citep{RecommenderSystems}.

\subsubsection{Indholdsbaserede anbefalinger}
Indholdsbaserede anbefalinger anbefaler ud fra brugerens tidligere handlinger i et system.
For hver bruger i et sådan system kan man tilskrive denne en smagsprofil, der beskriver hvor godt en bruger synes om forskellige attributter.
Handlingerne kan være vurderinger, sidevisninger, eller tidligere køb.
Hvert objekt i sådan et system vil have nogle attributter, og ud fra disse, vil man kunne udregne en brugers smagsprofil.
Når systemet så har en smagsprofil på en bruger, vil det kunne sammenligne et objekts attributter med smagsprofilen, for at se om objektets attributter består af noget brugeren synes om.

Ved brug af denne anbefalingsmetode kan ``term frequency inverse document frequency'' (tf-idf) benyttes, som vægter hver faktor, efter den reciprokke hyppighed den er i datamængden.
Dette hjælper til at skelne mellem termer der optræder ofte, og termer der optræder sjældent.
Hvis et term ikke forekommer så ofte tillægges det derfor en højere betydning end et term med oftere forekomst.

Denne implementering af anbefaling kræver at man har nogle attributter tilhørende de objekter man gerne vil anbefale brugerne.
Den største fordel ved denne metode  er at man kan lave personlige anbefalinger lige så snart en bruger har generet data, til en smagsprofil.
Ulemperne er man skal have gode attributter til sine data, for denne metode virker. 
Ligeledes kan denne implementering heller ikke tage højde for betingede regler, eksempelvis hvis man kun kan lide attribut1 i forbindelse med atrribut2 men ikke kan fordrage attribut1 i forbindelse med attribut3.

\subsubsection{Kollaborativ anbefalinger}
Kollaborativ anbefalinger er også bygget op om smagsprofiler.
Denne implementation kræver, modsat den indholdsbaserede, ingen data om de objekter som systemet skal anbefale. 
I denne metode tager man i stedet brugernes smagsprofiler og holder op mod andre brugeres for at finde anbefalinger til en bruger.
I \myref{tabel:kollabrativ} ses et eksempel på hvordan denne implementation kan fungere i praksis.

Fordelene ved denne er som nævnt, at den kan bruges på mangelfulde data, hvortil dårlige eller ingen attributter er tilgængelige.
Ligeledes slipper man også for problemet om betingede regler.
Dog er en stor ulempe ved denne metode, det man betegner som ‘cold start’-problemet, hvor man mangler mange brugeres vurderinger, for at kunne give dem anbefalinger.\citep{RecommenderSystems}.
\input{images/Tables/kollabrativ.tex}

\subsection{Design}
Vi har valgt at implementere to forskellige sorteringer. %TROELS ER IMOD DETTE!!!!!
Den første er en simpel, ikke personliggjort anbefaling, som blot er de gennemsnitlige bedømmelser, sorteret faldende.
Ligeledes har vi valgt at implementere en personlig anbefaling, her har vi valgt en indholdsbaseret sortering, sorteret efter brugerens beregnede forventede vurdering, baseret på brugerens vurderinger af andre opskrifter.
Dette valg har vi foretaget hovedsageligt af to årsager, den første er fordi vi mener at ingredienserne på hver opskrift kan bruges som attributter til at generere smagsprofiler og derfor også anbefalinger udefra.
Den anden årsag, til at valget er faldet på denne løsning, er at vil gerne ville undgå ‘cold-start’ problemet.
Vi har valgt ikke at implementere tf-idf af det inholdsbaserede anbefalingssystem.

Implementeringen, som tidligere nævnt, baserer anbefalingerne på opskrifters ingredienser.
Når en bruger har bedømt en opskrift, får hver ingrediens til opskriften tildelt samme bedømmelse.
Hvis en ingrediens er bedømt på mere end en opskrift, bruges gennemsnittet af de samlede bedømmelser for ingrediensen.
Hvis en ingrediens ikke har nogen bedømmelse, bliver denne ingrediens tildelt gennemsnittet af alle brugerens bedømmelser.
Ud fra denne data oprettes en smagsprofil for hver bruger, som indeholder en værdi mellem 1-5, for hver ingrediens.

Derefter tager vi blot gennemsnittet af alle værdierne for hver opskrift, for at estimere hvor godt en bruger ville kunne lide en opskrift.
Modellen fungerer som vist på figur \myref{tabel:opskriftanbefaling}.
\input{images/Tables/opskriftanbefaling.tex}

I brugergrænsefladen har brugeren mulighed for at vælge hvordan opskrifter skal sorteres.
De kan vælge mellem de to beskrevet her, samt at få sorteret dem efter nyeste og ældste.
På forsiden præsenteres ligeledes de opskrifter som systemet regner højest forventede score ud på.

\subsection{Implementering}
Kernen i denne funktionalitet ligger i en metode, metoden \class{ReccomendRecipes}.
Denne metode findes i RecipesController.
Metoden gennemgår alle opskrifter for den givne bruger, og regner på baggrund af ingredienserne i disse, en forventet vurdering ud, som beskrevet i forrige afsnit.

Det første som funktionen gør, hvilket man ikke ser på \myref{recommendrecipes}, er at finde alle opskrifter en bruger har vureret.
Derefter tjekkes om der brugeren har nogle opskrifter, som er vurderet.
En foreach-løkke bliver gennemløbet for hver opskrift, en bruger har vurderet, og heri bliver den gennemsnitlige vurdering af de forskelige ingredieser tilføjet til en liste af Tuples.

Dernæst gennemgås en ny foreach, hvori den forventede vurdering for alle opskrifter af brugeren udregnes, på baggrund af ingredienserne i hver opskrift.
Til sidst sorteres denne liste af opskrifter, efter forventet vurdering.

\begin{lstlisting}[caption=Metoden \class{RecommendRecipes}. Sorterer opskrifter efter forventede vurdering for en given bruger., label=recommendrecipes]
public IEnumerable<Recipe> RecommendRecipes(User user)
{
    /* [...] */
    // Pair the ingrdients with the rating given
    // If two ingredients are the same, take the avg of both ratings.
    var itemsWithRatings = new List<Tuple<Item, List<decimal>>>();
    foreach (var recipie in recipiesRatedByUser.ToList())
    {
        var score = recipie.Ratings.FirstOrDefault(x => x.User.Username == user.Username).Score;
        [...]
    }

    var avgRating = recipiesRatedByUser.Average(x => x.Ratings.FirstOrDefault(y => y.User.ID == user.ID).Score);
    [...]
    // Calculate the score for every recipie
    foreach (var recipie in _db.Recipes.Include(x => x.Ingredients).Include(x => x.Ratings))
    {
        if (recipie.Ratings.FirstOrDefault(y => y.User.ID == user.ID) != null)
        {
            recipiesRated.Add(new Tuple<Recipe, decimal>(recipie, recipie.Ratings.FirstOrDefault(y => y.User.ID == user.ID).Score));
        }
        else
        {
            var score = new List<decimal>();
            foreach (var ingredient in recipie.Ingredients)
            {
                var derp = (itemsWithRatings.FirstOrDefault(x => x.Item1.Equals(ingredient)));
                score.Add(derp != null ? derp.Item2.Average() : avgRating);
            }
            recipiesRated.Add(new Tuple<Recipe, decimal>(item1: recipie, item2: score.Any() ? score.Average() : 0M));
        }
    }
    // Sort the recipies descending and return itz
    return recipiesRated.OrderByDescending(x => x.Item2).Select(x => x.Item1);
}
\end{lstlisting}

Metoden returner en liste af alle opskrifterne, hvori de er sorteret efter deres forventede vurdering, bemærk at vurderede opskrifter ligger i samme liste, og har værdien, som brugeren har vurderet disse.

\subsection{Konklusion}
Implementeringen af anbefalingerne virker efter hensigten.
Den simple anbefaling, der sorterer efter højest gennemsnitlige vurderinger, er meget simpel men kan være brugbar.
Problemerne ved denne er dog at vi ingen nedre grænse har, for hvor mange bedømmelser der skal være, derfor vil en opskrift med én vurdering på 5 ligge højere end en opskrift med 49 vurderinger på 5 og én vurdering på 4.
Dette er en tydelig svaghed, som kunne forbedres uden store ændringer i koden.
Ligeledes ville en forbedring også være at sikre sig, at hvis to eller flere opskrifter har samme gennemsnitlige vurdering, så ville opskriften med flest vurderinger vægtes højest.

Vores sortering efter forventet vurdering, fungerer også til dels efter hensigten, dog kunne algoritmen godt bruge forfinelse, eftersom der ikke er lagt stor vægt på ingredienser man ikke har bedømt.
Hvis dette skulle gøres kunne ingredienser eventuelt vægtes efter hvor mange gange en bruger har bedømt denne vare.
Ligeledes kunne vi forestille os at en højere vægtning af sjældent forkommende ingredienser ville kunne præcisere anbefalingerne ved at bruge tf-idf.

Disse forbedringer har vi fravalgt at implementere, da de ikke er en del af kerneområdet i dette projektforløb.
