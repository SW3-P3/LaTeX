\section{Black Box Testing}\label{BBtest}
For at sikre funktionaliteterne i systemets korrekthed, er der konstrueret unit tests, disse kan findes i \class{ProjectFood.Tests} projektet.
En af de metoder, som er taget i brug, er Black Box Testing eller Behavioral Testing.
En sådan test udføres ved at give et input til et kørbart system, og derefter verificere ens output.
Det eneste i denne process der er kendt af testpersonen er input og output, selve funktionaliteten er således gemt i en ``Black Box''. \citep{Black_Box}

Til dette formål anvendes NUnit frameworket, som er et unit-testing framework til alle .Net sprogene.
Vi bruger NUnit attributten \class{[TestFixture]} på den pågældende testklasse, dette gør det muligt at have \class{[SetUp]} og \class{[TearDown]} i sine tests.
En metode med attributten \class{[Setup]} køres hver gang inden en test køres, og gør data klar i hukommelsen så det kan behandles.
\class{[TearDown]} køres derimod efter hver test og kan bruges til at frigive hukommelse osv.
Ved NUnit bruges desuden attributten \class{Test} til at markere at en metode i en klasse markeret med \class{TestFixture} er en test.
Der kan ikke sendes input til en \class{[Test]} 
Der bruges ved testmetoder der skal have et input \class{[TestCase(inputA, inputB, Result=value)]} attributten, hvor inputtet sendes til testen sekventielt.
\class{Result=value} tester når metoden er returnere om det returnere den satte værdi i \class{value}. 
Efter tests er lavet på metoder af systemet som ikke kalder andre metoder, kan metoderne med flere dependencies, så testes, med en sikkerhed om, at deres dependencies er funktionelle.
\citep{Unit_Testing}

For at oprette diverse tests, følges AAA mønsteret (Act, Assert, Arrange), dette er en måde hvorpå unit tests kan konstrueres, for at give et bedre overblik over de forskellige dele af testen.
\citep{Writing_Your_Tests}
De tre dele af AAA mønsteret repræsentere respektivt:
\begin{itemize}
  \item \textbf{Arrange:} Her initialiseres det data der skal bruges i testen. Da vi Bruger NUnit sker dette udelukkende for mange tests i \class{Initilize()} metoden, der er dog nogle som har sin egen Arrange sektion som initialisere data der kun skal bruges i den enkelte test.
  \item \textbf{Act:} Her kaldes den kode som ønskes testet, såvel som gemmer eventuelle resultater i variabler, hvilke bruges i Assert.
  \item \textbf{Assert:} Her specificeres hvad der skal være sket i act, og tjekkes om ændringer i data og eventuelle resultater, stemmer overens med det forventede resultat af metode kaldet.
\end{itemize}
Der benyttes i nogle tests også et \textbf{PreCondition}, felt der sikre at de ændringer der foretages i \textbf{Act} ikke er foretaget inden Act. 
Dermed sikres der at \textbf{Assert} ikke blot giver positive resultater fordi det som tjekkes for allerede var sandt før \textbf{Act}.
Givet at testen er skrevet korrekt kan der ved brug af dette system findes potentielle fejl i systemets metoder.


Til hver enkelt testede funktionalitet oprettes tests der går igennem mange af stierne i funktionen, for at være sikker på at de  agerer som det forventes.
På \myref{lsttest} ses en test for metoden \class{ShareList} i \class{ShoppingListcontroller}. I testen tjekkes der hvorvidt den \class{User} der deles en \class{ShoppingList} med, har den delte \class{ShoppingList} efter kaldet.
Der oprettes også en ekstra Arrange her for at oprette en \class{User} der kan deles med.

\begin{lstlisting}[caption={Test for metoden \class{ShareList}.}, label=lsttest]
{
    [TestFixture]
    public class TestShoppingListsController
    {
    	[SetUp]
        public void Initialize()
        {
          //Some Mock Data
        }
        [Test]
        public void ShoppingListShareList_DemoMail2UserAsInput_ShouldShare()
        {
            //Arrange
            var user2 = DemoGetMethods.GetDemoUser(2);
            user2.Username = "DemoMail2";
            _mockdata.Users.Add(user2); 

            //PreCondition
            Assert.IsFalse(_mockdata.ShoppingLists.First(x=>x.ID == 1).Users.Count == 2);
            Assert.IsTrue(_mockdata.Users.First(i => i.Username == "DemoUser").ShoppingLists.Any(x=>x.ID == 1));
            Assert.IsFalse(_mockdata.Users.First(i => i.Username == "DemoMail2").ShoppingLists.Any(x=>x.ID == 1));

            //Act
            var result = _controller.ShareList(1, "DemoMail2");

            //Assert
            Assert.IsNotNull(result);
            Assert.IsTrue(_mockdata.Users.First(i => i.Username == "DemoUser").ShoppingLists.Any(x => x.ID == 1));
            Assert.IsTrue(_mockdata.Users.First(i => i.Username == "DemoMail2").ShoppingLists.Any(x => x.ID == 1));
            Assert.IsTrue(_mockdata.ShoppingLists.First(x => x.ID == 1).Users.Count == 2);
        }
}        
\end{lstlisting}
Der findes desuden en lignende test som kaldes \class{..._ShouldNotShare}, som ikke opfylder alle metodens kriterier, og derfor fejler, hvilket så tjekkes igennem asserts.
Fordelen ved at bruge Unit tests som Black Box tests frem for andre, er muligheden for at køre tests nemt igen og igen.
Dette er en stor fordel når man arbejder iterativt.
Dette er en mulighed der ellers ikke nødvendigvis er tilgængelig for alle typer af Black Box tests, eksempelvis hvis systemet testes igennem brug.
Disse tests ville skulle udføres manuelt hver gang, hvor dette ikke er tilfældet ved brug af unit testing.
Dette kommer til gavn når der laves eventuelle ændringer i systemet i en iteration, alle tests lavet førhen kan køres for at se om ændringerne har haft nogen effekt på det ellers før funktionelle system. 
Der benyttes yderligere et library kaldet moq, dette er et library lavet for at kunne oprette mock data, samt de dependencies der nu må høre til.
I vores tests benyttes dette til at simulere hvorom en bruger er authenticated eller ej, dette tillader at teste funktionaliteter der kræver at en bruger er authenticated, såvel som at teste hvad der sker, hvis en bruger ikke er authenticated.

Der benyttes endvidere NCover Bolt extension til Visual Studio. 
Dette hjælper med at vise hvilke code paths der tages igennem testene, hvilket giver os testenes code coverage.
Oftest sigter man efter 80\% code coverage i projekter. \citep{Code_Coverage}
De testede komponenter består af komponenterne beskrevet i \myref{subsec:komp}, dette er altså filerne: \class{RecipeController.cs}, \class{ShoppingListController.cs}, \class{OfferController.cs}, \class{UserController.cs},  og en lille del af \class{AccountController.cs}.

\class{AccountController.cs} testes kun for metoden \class{Register()} da dette er det eneste sted vi selv har kodet i denne controller, resten af controlleren er en del Microsoft OWIN.
Dette giver dermed kun 10\% code coverage i denne fil, imens de resterende filer foruden \class{OfferController.cs}  har 80\% eller mere.
\class{OfferController.cs} er kun på 73\% da denne indeholder \class{ImportOffers()} der henter tilbudene fra eTilbudsavis' API. 
Denne metode er ikke testet da den tager op imod 8 minutter før den afsluttes, hvilket er problematisk når unit tests skal være hurtige og effektive.

Code Coverage tallet viser os at meget af koden er testet.
Med denne coverage og det faktum at vores tests ikke fejler, konkluderes det ikke nødvendigvis at koden er af høj kvalitet, men blot at koden opfører sig som forventet.
